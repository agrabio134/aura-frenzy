<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>$AURA Frenzy</title>
  <link rel="icon" type="image/png" href="aura.jpg">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: radial-gradient(circle, #2a1a5e, #0d0b2f);
      overflow: hidden;
      font-family: 'Press Start 2P', cursive;
    }
    canvas {
      display: none;
      width: 100vw !important;
      height: 100vh !important;
    }
    #menu, #mode-selection, #name-input, #avatar-menu, #nft-marketplace, #lobby, #leaderboard-end {
      text-align: center;
      padding: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 3px solid #7b68ee;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(123, 104, 238, 0.5);
      max-width: 500px;
      width: 90%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #menu h1, #mode-selection h1, #name-input h1, #avatar-menu h1, #nft-marketplace h1, #lobby h1, #leaderboard-end h1 {
      font-size: 32px;
      color: #7b68ee;
      text-shadow: 0 0 10px #7b68ee, 0 0 20px #7b68ee;
      margin-bottom: 40px;
      letter-spacing: 2px;
    }
    #nft-marketplace p, #lobby p, #leaderboard-end p {
      color: #fff;
      font-size: 16px;
      margin-bottom: 20px;
    }
    #menu .button-container, #mode-selection .button-container, #name-input .button-container, #avatar-menu .button-container, #nft-marketplace .button-container, #lobby .button-container, #leaderboard-end .button-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    #menu button, #mode-selection button, #name-input button, #avatar-menu button, #nft-marketplace button, #lobby button, #leaderboard-end button {
      padding: 15px 30px;
      font-size: 16px;
      font-family: 'Press Start 2P', cursive;
      color: #fff;
      border: 2px solid #7b68ee;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    #menu button.play, #mode-selection button.play, #name-input button.play, #avatar-menu button.play, #nft-marketplace button.play, #lobby button.play, #leaderboard-end button.play {
      background: linear-gradient(45deg, #7b68ee, #483d8b);
    }
    #menu button.play:hover, #mode-selection button.play:hover, #name-input button.play:hover, #avatar-menu button.play:hover, #nft-marketplace button.play:hover, #lobby button.play:hover, #leaderboard-end button.play:hover {
      background: linear-gradient(45deg, #6a5acd, #3c2f6b);
      box-shadow: 0 0 15px #7b68ee;
      transform: scale(1.05);
    }
    #menu button:disabled, #mode-selection button:disabled, #name-input button:disabled, #avatar-menu button:disabled, #nft-marketplace button:disabled, #lobby button:disabled, #leaderboard-end button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #name-input input, #lobby select {
      padding: 10px;
      font-size: 16px;
      font-family: 'Press Start 2P', cursive;
      color: #7b68ee;
      background: #2a1a5e;
      border: 2px solid #7b68ee;
      border-radius: 5px;
      width: 80%;
      margin-bottom: 20px;
      text-align: center;
    }
    #avatar-menu .options {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    #avatar-menu .option {
      padding: 10px;
      border: 2px solid #7b68ee;
      border-radius: 5px;
      cursor: pointer;
      background: #2a1a5e;
      color: #fff;
      font-size: 14px;
    }
    #avatar-menu .option.selected {
      background: #7b68ee;
      color: #000;
    }
    #avatar-menu .preview {
      width: 100px;
      height: 100px;
      margin: 20px auto;
      border: 2px solid #7b68ee;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      background-image: url('aura.jpg');
      background-size: cover;
      background-position: center;
    }
    #lobby .player-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 20px;
      color: #fff;
      font-size: 14px;
    }
    #lobby .player-list div {
      display: flex;
      justify-content: space-between;
      padding: 5px 10px;
      border-bottom: 1px solid #7b68ee;
    }
    #lobby .countdown {
      font-size: 36px;
      color: #ff4500;
      text-shadow: 0 0 15px #ff4500;
      margin-bottom: 30px;
      text-align: center;
    }
    #leaderboard-end .leaderboard-list {
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 20px;
      color: #fff;
      font-size: 14px;
    }
    #leaderboard-end .leaderboard-list div {
      display: flex;
      justify-content: space-between;
      padding: 5px 10px;
      border-bottom: 1px solid #7b68ee;
    }
    #joystick {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 80px;
      background: rgba(123, 104, 238, 0.4);
      border: 2px solid #7b68ee;
      border-radius: 50%;
      display: none;
      box-shadow: 0 0 10px rgba(123, 104, 238, 0.5);
      touch-action: none;
    }
    #joystick-knob {
      position: absolute;
      width: 32px;
      height: 32px;
      background: #7b68ee;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px #7b68ee;
    }
    #skill-button, #lock-button {
      position: fixed;
      bottom: 30px;
      right: 15px;
      width: 50px;
      height: 50px;
      background: linear-gradient(45deg, #ff4500, #d83b01);
      border: 2px solid #7b68ee;
      border-radius: 50%;
      color: #fff;
      text-align: center;
      line-height: 50px;
      font-size: 10px;
      font-family: 'Press Start 2P', cursive;
      display: none;
      box-shadow: 0 0 10px #ff4500;
    }
    #lock-button {
      bottom: 30px;
      right: 75px;
    }
    #timer-display {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #7b68ee;
      font-size: 16px;
      font-family: 'Press Start 2P', cursive;
      text-shadow: 0 0 10px #7b68ee;
      display: none;
    }
    @media (max-width: 600px) {
      #menu, #mode-selection, #name-input, #avatar-menu, #nft-marketplace, #lobby, #leaderboard-end {
        padding: 15px;
      }
      #menu h1, #mode-selection h1, #name-input h1, #avatar-menu h1, #nft-marketplace h1, #lobby h1, #leaderboard-end h1 {
        font-size: 24px;
        margin-bottom: 30px;
      }
      #menu button, #mode-selection button, #name-input button, #avatar-menu button, #nft-marketplace button, #lobby button, #leaderboard-end button {
        font-size: 14px;
        padding: 12px 25px;
      }
      #lobby .countdown {
        font-size: 28px;
        margin-bottom: 20px;
      }
      #joystick, #skill-button, #lock-button {
        display: block;
      }
      #timer-display {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>$AURA FRENZY</h1>
    <div class="button-container">
      <button class="play" onclick="showModeSelection()"><i class="fas fa-play"></i> Play</button>
      <button class="play" onclick="showAvatarMenu()"><i class="fas fa-paint-brush"></i> Avatar</button>
      <button class="play" onclick="showNFTMarketplace()"><i class="fas fa-shopping-cart"></i> NFT Marketplace</button>
      <button class="play" onclick="showLeaderboard()"><i class="fas fa-trophy"></i> AURA Leaderboard</button>
    </div>
  </div>
  <div id="mode-selection" style="display: none;">
    <h1>SELECT MODE</h1>
    <div class="button-container">
      <button class="play" onclick="showNameInput('single')"><i class="fas fa-user"></i> Single Player</button>
      <button class="play" onclick="showNameInput('multi')"><i class="fas fa-users"></i> Multiplayer</button>
    </div>
  </div>
  <div id="name-input" style="display: none;">
    <h1>ENTER NAME</h1>
    <input type="text" id="player-name" maxlength="12" placeholder="Your Name">
    <div class="button-container">
      <button class="play" onclick="joinGame()"><i class="fas fa-play"></i> Join Game</button>
    </div>
  </div>
  <div id="lobby" style="display: none;">
    <h1>LOBBY</h1>
    <p id="countdown" class="countdown" style="display: none;"></p>
    <select id="game-duration" style="display: none;">
      <option value="300">5 Minutes</option>
      <option value="420">7 Minutes</option>
      <option value="600" selected>10 Minutes</option>
      <option value="900">15 Minutes</option>
      <option value="1800">30 Minutes</option>
      <option value="3600">1 Hour</option>
    </select>
    <div id="player-list" class="player-list"></div>
    <div class="button-container">
      <button class="play" id="spectate-button" onclick="toggleSpectate()" style="display: none;"><i class="fas fa-eye"></i> Spectate</button>
      <button class="play" id="ready-button" onclick="toggleReady()"><i class="fas fa-check"></i> Ready</button>
      <button class="play" id="start-button" onclick="startGame()" disabled><i class="fas fa-play"></i> Start Game</button>
      <button class="play" onclick="returnToMenu()"><i class="fas fa-arrow-left"></i> Back</button>
    </div>
  </div>
  <div id="avatar-menu" style="display: none;">
    <h1>CUSTOMIZE AVATAR</h1>
    <div class="options" id="color-options">
      <h3 style="color: #7b68ee; width: 100%;">Aura Color</h3>
      <div class="option" data-color="#E6E6FA">Cosmic Lavender</div>
      <div class="option" data-color="#7B68EE">Nebula Purple</div>
      <div class="option" data-color="#00CED1">Stellar Cyan</div>
    </div>
    <div class="options" id="accessory-options">
      <h3 style="color: #7b68ee; width: 100%;">Aura Symbol</h3>
      <div class="option" data-accessory="✨">Cosmic Spark</div>
      <div class="option" data-accessory="🌌">Nebula Swirl</div>
      <div class="option" data-accessory="🔮">Mystic Rune</div>
    </div>
    <div class="preview" id="avatar-preview"></div>
    <div class="button-container">
      <button class="play" onclick="saveAvatar()"><i class="fas fa-save"></i> Save Avatar</button>
      <button class="play" onclick="returnToMenu()"><i class="fas fa-arrow-left"></i> Back</button>
    </div>
  </div>
  <div id="nft-marketplace" style="display: none;">
    <h1>NFT MARKETPLACE</h1>
    <p style="color: #fff !important;">Explore and purchase unique Aura NFTs!</p>
    <div class="button-container">
      <button class="play" disabled title="Marketplace is locked" style="opacity: 0.6; cursor: not-allowed;">
        <i class="fas fa-lock"></i> Marketplace Locked
      </button>
      <button class="play" onclick="returnToMenu()"><i class="fas fa-arrow-left"></i> Back</button>
    </div>
  </div>
  <div id="leaderboard-end" style="display: none;">
    <h1>FINAL LEADERBOARD</h1>
    <div id="leaderboard-list" class="leaderboard-list"></div>
    <div class="button-container">
      <button class="play" onclick="returnToMenu()"><i class="fas fa-arrow-left"></i> Back to Menu</button>
    </div>
  </div>
  <div id="joystick">
    <div id="joystick-knob"></div>
  </div>
  <div id="skill-button"><i class="fas fa-bolt"></i> Surge</div>
  <div id="lock-button"><i class="fas fa-lock"></i> Lock</div>
  <div id="timer-display"></div>
  <script>
    let socket;
    let gameStarted = false;
    let gameMode = null;
    let playerName = '';
    let worldWidth = 4000;
    let worldHeight = 4000;
    let cameraX = 0;
    let cameraY = 0;
    let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    let joystick = { active: false, x: 0, y: 0, baseX: window.innerWidth / 2, baseY: window.innerHeight - 100 };
    let playerId = null;
    let isAlive = true;
    let cameraLocked = false;
    let isHost = false;
    let isSpectating = false;
    let lastTapTime = 0;
    let tapCount = 0;

    // Avatar settings
    let avatar = {
      color: safeStorageAccess('avatarColor') || '#E6E6FA',
      accessory: safeStorageAccess('avatarAccessory') || '✨'
    };

    // Single-player state
    let player;
    let bots = [];
    let stardust = [];
    let foods = [];
    let vortexes = [];
    let nebulaZones = [];
    let botNames = ["Star", "Nebula", "Pulse", "Glow", "Cosmo", "Flare"];
    let leaderboard = [];
    let surgeActive = false;
    let surgeCooldown = 0;
    let surgeTimer = 0;
    let absorbTimer = 0;

    // Multiplayer state
    let gameState = { players: {}, bots: [], debris: [], pipes: [], clogZones: [], leaderboard: [], lobby: { players: {}, hostId: null, isGameStarted: false, countdown: -1, duration: 600 } };

    function setup() {
      if (gameStarted && gameState.lobby.isGameStarted && gameState.lobby.countdown <= 0) {
        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        createCanvas(canvasWidth, canvasHeight);
        if (gameMode === 'single') {
          player = new AuraOrb(worldWidth / 2, worldHeight / 2, 10, true);
          player.name = playerName || 'Starfarer';
          player.avatar = avatar;
          for (let i = 0; i < 10; i++) {
            let bot = new AuraOrb(random(worldWidth), random(worldHeight), 10, false);
            bot.name = botNames[i % botNames.length] + i;
            bot.avatar = {
              color: random(['#E6E6FA', '#7B68EE', '#00CED1']),
              accessory: random(['✨', '🌌', '🔮'])
            };
            bots.push(bot);
          }
          for (let i = 0; i < 1000; i++) {
            stardust.push(new Stardust());
            foods.push(new Food());
          }
          for (let i = 0; i < 20; i++) {
            vortexes.push(new Vortex());
          }
          for (let i = 0; i < 5; i++) {
            nebulaZones.push(new NebulaZone());
          }
        }
        if (isMobile) {
          setupTouchControls();
        }
      }
    }

    function draw() {
      if (gameStarted && isAlive && gameMode === 'multi' && !gameState.lobby.isGameStarted) {
        document.getElementById('lobby').style.display = 'block';
        document.getElementById('timer-display').style.display = 'none';
        const canvas = document.querySelector('canvas');
        if (canvas) {
          canvas.style.display = 'none';
        }
        return;
      }

      if (gameStarted && isAlive && gameState.lobby.isGameStarted && gameState.lobby.countdown > 0) {
        document.getElementById('lobby').style.display = 'block';
        document.getElementById('countdown').style.display = 'block';
        document.getElementById('timer-display').style.display = 'none';
        document.getElementById('countdown').textContent = gameState.lobby.countdown;
        const canvas = document.querySelector('canvas');
        if (canvas) {
          canvas.style.display = 'none';
        }
        return;
      }

      if (gameStarted && isAlive && gameState.lobby.isGameStarted && gameState.lobby.countdown <= 0) {
        const canvas = document.querySelector('canvas');
        if (canvas) {
          canvas.style.display = 'block';
        }
        document.getElementById('timer-display').style.display = 'block';
        updateTimerDisplay();

        if (gameMode === 'single') {
          if (surgeActive) {
            surgeTimer--;
            if (surgeTimer <= 0) {
              surgeActive = false;
              surgeCooldown = 600;
            }
          } else if (surgeCooldown > 0) {
            surgeCooldown--;
          }

          if (!cameraLocked) {
            cameraX = lerp(cameraX, player.pos.x - width / 2, 0.1);
            cameraY = lerp(cameraY, player.pos.y - height / 2, 0.1);
          } else {
            cameraX = player.pos.x - width / 2;
            cameraY = player.pos.y - height / 2;
          }

          background(10, 15, 50);
          push();
          translate(-cameraX, -cameraY);
          stroke(50, 60, 120);
          strokeWeight(1);
          for (let x = 0; x < worldWidth; x += 50) {
            line(x, 0, x, worldHeight);
          }
          for (let y = 0; y < worldHeight; y += 50) {
            line(0, y, worldWidth, y);
          }

          stroke(123, 104, 238);
          strokeWeight(3);
          noFill();
          rect(0, 0, worldWidth, worldHeight);

          for (let zone of nebulaZones) {
            zone.show();
            zone.update();
          }

          for (let d of stardust) {
            d.show();
          }

          for (let f of foods) {
            f.show();
          }

          for (let vortex of vortexes) {
            vortex.show();
          }

          let inNebulaZone = false;
          for (let zone of nebulaZones) {
            if (p5.Vector.dist(player.pos, zone.pos) < zone.r) {
              inNebulaZone = true;
              absorbTimer++;
              if (absorbTimer >= 600) {
                player.r += 10;
                nebulaZones.splice(nebulaZones.indexOf(zone), 1);
                nebulaZones.push(new NebulaZone());
                absorbTimer = 0;
              }
              break;
            }
          }
          if (!inNebulaZone) absorbTimer = 0;

          player.inNebulaZone = inNebulaZone;
          player.update();
          player.show();

          for (let bot of bots) {
            let botInNebulaZone = false;
            for (let zone of nebulaZones) {
              if (p5.Vector.dist(bot.pos, zone.pos) < zone.r) {
                botInNebulaZone = true;
                break;
              }
            }
            bot.inNebulaZone = botInNebulaZone;
            bot.update();
            bot.show();
          }

          for (let i = stardust.length - 1; i >= 0; i--) {
            if (player.clears(stardust[i])) {
              stardust.splice(i, 1);
              stardust.push(new Stardust());
            }
          }

          for (let i = foods.length - 1; i >= 0; i--) {
            if (player.clearsFood(foods[i])) {
              foods.splice(i, 1);
              foods.push(new Food());
            }
          }

          for (let bot of bots) {
            for (let i = stardust.length - 1; i >= 0; i--) {
              if (bot.clears(stardust[i])) {
                stardust.splice(i, 1);
                stardust.push(new Stardust());
              }
            }
            for (let i = foods.length - 1; i >= 0; i--) {
              if (bot.clearsFood(foods[i])) {
                foods.splice(i, 1);
                foods.push(new Food());
              }
            }
          }

          for (let i = bots.length - 1; i >= 0; i--) {
            if (player.canClear(bots[i])) {
              player.clearAuraOrb(bots[i]);
              bots.splice(i, 1);
              let newBot = new AuraOrb(random(worldWidth), random(worldHeight), 10, false);
              newBot.name = botNames[i % botNames.length] + i;
              newBot.avatar = {
                color: random(['#E6E6FA', '#7B68EE', '#00CED1']),
                accessory: random(['✨', '🌌', '🔮'])
              };
              bots.push(newBot);
            } else if (bots[i].canClear(player)) {
              isAlive = false;
              gameStarted = false;
              if (socket) {
                socket.disconnect();
                socket = null;
              }
              remove();
              location.reload();
              return;
            }
          }

          for (let i = bots.length - 1; i >= 0; i--) {
            for (let j = bots.length - 1; j >= 0; j--) {
              if (i !== j && bots[i].canClear(bots[j])) {
                bots[i].clearAuraOrb(bots[j]);
                bots.splice(j, 1);
                let newBot = new AuraOrb(random(worldWidth), random(worldHeight), 10, false);
                newBot.name = botNames[j % botNames.length] + j;
                newBot.avatar = {
                  color: random(['#E6E6FA', '#7B68EE', '#00CED1']),
                  accessory: random(['✨', '🌌', '🔮'])
                };
                bots.push(newBot);
              }
            }
          }

          pop();

          updateLeaderboard();
          drawLeaderboard();
          drawMinimap();
          drawSurgeStatus();
          drawAbsorbStatus();
        } else {
          if (!gameState.players[playerId] || (!isSpectating && !gameState.players[playerId].isActive)) {
            return;
          }

          if (!isSpectating) {
            let input = {};
            if (isMobile && joystick.active) {
              input.joystick = { x: joystick.x / 25, y: joystick.y / 25 };
            } else {
              input.mouse = { x: mouseX + cameraX, y: mouseY + cameraY };
            }
            if (socket) {
              socket.emit('playerInput', input);
            }
          } else {
            if (!isMobile || joystick.active) {
              let input = {};
              input.mouse = {
                x: cameraX + width / 2 + (isMobile ? joystick.x * 10 : mouseX),
                y: cameraY + height / 2 + (isMobile ? joystick.y * 10 : mouseY)
              };
              if (socket) {
                socket.emit('spectatorInput', input);
              }
            }
          }

          if (!cameraLocked) {
            cameraX = lerp(cameraX, gameState.players[playerId].pos.x - width / 2, 0.1);
            cameraY = lerp(cameraY, gameState.players[playerId].pos.y - height / 2, 0.1);
          } else {
            cameraX = gameState.players[playerId].pos.x - width / 2;
            cameraY = gameState.players[playerId].pos.y - height / 2;
          }

          background(10, 15, 50);
          push();
          translate(-cameraX, -cameraY);
          stroke(50, 60, 120);
          strokeWeight(1);
          for (let x = 0; x < worldWidth; x += 50) {
            line(x, 0, x, worldHeight);
          }
          for (let y = 0; y < worldHeight; y += 50) {
            line(0, y, worldWidth, y);
          }

          stroke(123, 104, 238);
          strokeWeight(3);
          noFill();
          rect(0, 0, worldWidth, worldHeight);

          if (Array.isArray(gameState.clogZones)) {
            for (let zone of gameState.clogZones) {
              fill(75, 0, 130, 150);
              noStroke();
              ellipse(zone.pos.x, zone.pos.y, zone.r * 2);
              fill(123, 104, 238, 100);
              ellipse(zone.pos.x, zone.pos.y, zone.r * 1.5);
            }
          }

          if (Array.isArray(gameState.debris)) {
            for (let d of gameState.debris) {
              fill(75, 0, 130);
              noStroke();
              ellipse(d.pos.x, d.pos.y, d.r * 2);
            }
          }

          if (Array.isArray(gameState.pipes)) {
            for (let p of gameState.pipes) {
              fill(169, 169, 169);
              noStroke();
              ellipse(p.pos.x, p.pos.y, p.r * 2);
            }
          }

          if (gameState.players) {
            for (let id in gameState.players) {
              let player = gameState.players[id];
              if (player.spectating) continue;
              let isHidden = false;
              if (Array.isArray(gameState.pipes)) {
                for (let pipe of gameState.pipes) {
                  let d = dist(player.pos.x, player.pos.y, pipe.pos.x, pipe.pos.y);
                  if (d < pipe.r + player.r) {
                    isHidden = true;
                    break;
                  }
                }
              }
              let [r, g, b] = hexToRgb(player.avatar.color);
              fill(r, g, b, isHidden ? 100 : 255);
              noStroke();
              ellipse(player.pos.x, player.pos.y, player.r * 2);
              for (let i = 0; i < 50; i++) {
                let angle = random(TWO_PI);
                let dist = random(player.r, player.r * 1.2);
                let x = player.pos.x + cos(angle) * dist;
                let y = player.pos.y + sin(angle) * dist;
                fill(r * 0.8, g * 0.8, b * 0.8, isHidden ? 50 : 200);
                ellipse(x, y, 3);
              }
              fill(255, 255, 255, isHidden ? 100 : 255);
              textAlign(CENTER, CENTER);
              textSize(player.r * 1.2);
              textStyle(BOLD);
              text(player.avatar.accessory, player.pos.x, player.pos.y);
              fill(255, 255, 255, isHidden ? 100 : 255);
              textAlign(CENTER);
              textSize(12);
              text(player.name, player.pos.x, player.pos.y - player.r - 10);
            }
          }

          if (Array.isArray(gameState.bots)) {
            for (let bot of gameState.bots) {
              let isHidden = false;
              if (Array.isArray(gameState.pipes)) {
                for (let pipe of gameState.pipes) {
                  let d = dist(bot.pos.x, bot.pos.y, pipe.pos.x, pipe.pos.y);
                  if (d < pipe.r + bot.r) {
                    isHidden = true;
                    break;
                  }
                }
              }
              let [r, g, b] = hexToRgb(bot.avatar.color);
              fill(r, g, b, isHidden ? 100 : 255);
              noStroke();
              ellipse(bot.pos.x, bot.pos.y, bot.r * 2);
              fill(255, 255, 255, isHidden ? 100 : 255);
              textAlign(CENTER, CENTER);
              textSize(bot.r * 1.2);
              text(bot.avatar.accessory, bot.pos.x, bot.pos.y);
              textAlign(CENTER);
              textSize(12);
              text(bot.name, bot.pos.x, bot.pos.y - bot.r - 10);
            }
          }

          pop();

          drawLeaderboard();
          drawMinimap();
          if (!isSpectating) {
            drawSurgeStatus();
            drawAbsorbStatus();
          }
        }
      }
    }

    function updateTimerDisplay() {
      let timeLeft = gameMode === 'multi' ? gameState.lobby.duration - gameState.lobby.gameTime : 0;
      let minutes = Math.floor(timeLeft / 60);
      let seconds = Math.floor(timeLeft % 60);
      document.getElementById('timer-display').textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function hexToRgb(hex) {
      hex = hex.replace('#', '');
      let r = parseInt(hex.substring(0, 2), 16);
      let g = parseInt(hex.substring(2, 4), 16);
      let b = parseInt(hex.substring(4, 6), 16);
      return [r, g, b];
    }

    function keyPressed() {
      if (keyCode === 32 && isAlive && !isSpectating) {
        if (gameMode === 'single' && !surgeActive && surgeCooldown <= 0) {
          surgeActive = true;
          surgeTimer = 180;
        } else if (gameMode === 'multi' && socket) {
          socket.emit('playerInput', { flushBoost: true });
        }
      } else if (keyCode === 76) {
        cameraLocked = !cameraLocked;
        document.getElementById('lock-button').innerHTML = cameraLocked ? '<i class="fas fa-lock"></i> Unlock' : '<i class="fas fa-lock"></i> Lock';
      }
    }

    function showModeSelection() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('mode-selection').style.display = 'block';
      document.getElementById('name-input').style.display = 'none';
      document.getElementById('avatar-menu').style.display = 'none';
      document.getElementById('nft-marketplace').style.display = 'none';
      document.getElementById('lobby').style.display = 'none';
      document.getElementById('leaderboard-end').style.display = 'none';
      document.getElementById('timer-display').style.display = 'none';
    }

    function showNameInput(mode) {
      gameMode = mode;
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('name-input').style.display = 'block';
      document.getElementById('player-name').focus();
      document.getElementById('timer-display').style.display = 'none';
    }

    function showAvatarMenu() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('avatar-menu').style.display = 'block';
      document.getElementById('timer-display').style.display = 'none';
      setupAvatarMenu();
    }

    function showNFTMarketplace() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('nft-marketplace').style.display = 'block';
      document.getElementById('timer-display').style.display = 'none';
    }

    function showLeaderboard() {
      document.getElementById('menu').style.display = 'block';
      document.getElementById('nft-marketplace').style.display = 'none';
      document.getElementById('avatar-menu').style.display = 'none';
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('name-input').style.display = 'none';
      document.getElementById('lobby').style.display = 'none';
      document.getElementById('leaderboard-end').style.display = 'none';
      document.getElementById('timer-display').style.display = 'none';
    }

    function setupAvatarMenu() {
      let colorOptions = document.getElementById('color-options').getElementsByClassName('option');
      let accessoryOptions = document.getElementById('accessory-options').getElementsByClassName('option');
      let preview = document.getElementById('avatar-preview');

      for (let option of colorOptions) {
        option.classList.remove('selected');
        if (option.dataset.color === avatar.color) {
          option.classList.add('selected');
        }
        option.onclick = () => {
          avatar.color = option.dataset.color;
          for (let o of colorOptions) o.classList.remove('selected');
          option.classList.add('selected');
          updateAvatarPreview();
        };
      }

      for (let option of accessoryOptions) {
        option.classList.remove('selected');
        if (option.dataset.accessory === avatar.accessory) {
          option.classList.add('selected');
        }
        option.onclick = () => {
          avatar.accessory = option.dataset.accessory;
          for (let o of accessoryOptions) o.classList.remove('selected');
          option.classList.add('selected');
          updateAvatarPreview();
        };
      }

      updateAvatarPreview();
    }

    function updateAvatarPreview() {
      let preview = document.getElementById('avatar-preview');
      preview.style.backgroundColor = avatar.color;
      preview.textContent = avatar.accessory;
    }

    function saveAvatar() {
      safeStorageAccess('avatarColor', avatar.color);
      safeStorageAccess('avatarAccessory', avatar.accessory);
      location.reload();
    }

    function returnToMenu() {
      gameStarted = false;
      isAlive = true;
      playerId = null;
      isHost = false;
      isSpectating = false;
      gameState = { players: {}, bots: [], debris: [], pipes: [], clogZones: [], leaderboard: [], lobby: { players: {}, hostId: null, isGameStarted: false, countdown: -1, duration: 600 } };
      const canvas = document.querySelector('canvas');
      if (canvas) {
        canvas.style.display = 'none';
      }
      document.getElementById('menu').style.display = 'block';
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('name-input').style.display = 'none';
      document.getElementById('avatar-menu').style.display = 'none';
      document.getElementById('nft-marketplace').style.display = 'none';
      document.getElementById('lobby').style.display = 'none';
      document.getElementById('leaderboard-end').style.display = 'none';
      document.getElementById('timer-display').style.display = 'none';
      if (gameMode === 'multi' && socket) {
        socket.disconnect();
        socket = null;
      }
      remove();
    }

    function joinGame() {
      playerName = document.getElementById('player-name').value.trim();
      if (playerName.length > 12) playerName = playerName.slice(0, 12);
      if (!playerName) playerName = 'Starfarer';
      document.getElementById('name-input').style.display = 'none';
      
      if (gameMode === 'single') {
        gameStarted = true;
        isAlive = true;
        const canvas = document.querySelector('canvas');
        if (canvas) {
          canvas.style.display = 'block';
        }
        setup();
      } else if (gameMode === 'multi') {
        socket = io('https://aura-frenzy.onrender.com');
        socket.on('connect', () => {
          console.log('Connected to server with ID:', socket.id);
          playerId = socket.id;
          socket.emit('joinLobby', { name: playerName, avatar });
          gameStarted = true;
          isAlive = true;
          document.getElementById('lobby').style.display = 'block';
        });
        socket.on('lobbyUpdate', (lobbyState) => {
          gameState.lobby = lobbyState;
          updateLobbyUI();
        });
        socket.on('gameState', (state) => {
          if (isAlive && state.players && state.players[playerId]) {
            isSpectating = state.players[playerId].spectating;
            state.clogZones = Array.isArray(state.clogZones) ? state.clogZones : [];
            state.debris = Array.isArray(state.debris) ? state.debris : [];
            state.pipes = Array.isArray(state.pipes) ? state.pipes : [];
            state.bots = Array.isArray(state.bots) ? state.bots : [];
            state.leaderboard = Array.isArray(state.leaderboard) ? state.leaderboard : [];
            gameState = state;
            if (gameState.lobby.isGameStarted && gameState.lobby.countdown <= 0) {
              document.getElementById('lobby').style.display = 'none';
              const canvas = document.querySelector('canvas');
              if (canvas) {
                canvas.style.display = 'block';
              }
              setup();
            }
          }
        });
        socket.on('flushed', (data) => {
          console.log('Flushed event received:', data);
          isAlive = false;
          gameStarted = false;
          playerId = null;
          isHost = false;
          isSpectating = false;
          gameState = { players: {}, bots: [], debris: [], pipes: [], clogZones: [], leaderboard: [], lobby: { players: {}, hostId: null, isGameStarted: false, countdown: -1, duration: 600 } };
          if (socket) {
            socket.disconnect();
            socket = null;
          }
          remove();
          location.reload();
        });
        socket.on('gameEnded', (finalLeaderboard) => {
          console.log('Game ended, showing leaderboard:', finalLeaderboard);
          isAlive = false;
          gameStarted = false;
          document.getElementById('lobby').style.display = 'none';
          document.getElementById('leaderboard-end').style.display = 'block';
          document.getElementById('timer-display').style.display = 'none';
          const canvas = document.querySelector('canvas');
          if (canvas) {
            canvas.style.display = 'none';
          }
          const leaderboardList = document.getElementById('leaderboard-list');
          leaderboardList.innerHTML = '';
          for (let i = 0; i < finalLeaderboard.length; i++) {
            const entry = document.createElement('div');
            entry.innerHTML = `<span>${i + 1}. ${finalLeaderboard[i].name}</span><span>Size: ${finalLeaderboard[i].size}</span>`;
            leaderboardList.appendChild(entry);
          }
          if (socket) {
            socket.disconnect();
            socket = null;
          }
          remove();
        });
        socket.on('connect_error', (error) => {
          console.error('Socket.IO connection error:', error);
          gameStarted = false;
          isAlive = false;
          isHost = false;
          isSpectating = false;
          if (socket) {
            socket.disconnect();
            socket = null;
          }
          remove();
          location.reload();
        });
      }
    }

    function toggleReady() {
      if (socket && gameMode === 'multi') {
        socket.emit('toggleReady');
      }
    }

    function toggleSpectate() {
      if (socket && gameMode === 'multi' && isHost) {
        socket.emit('toggleSpectate');
      }
    }

    function startGame() {
      if (socket && gameMode === 'multi' && isHost) {
        const duration = parseInt(document.getElementById('game-duration').value);
        socket.emit('startGame', { duration });
      }
    }

    function updateLobbyUI() {
      const playerList = document.getElementById('player-list');
      const readyButton = document.getElementById('ready-button');
      const startButton = document.getElementById('start-button');
      const spectateButton = document.getElementById('spectate-button');
      const durationSelect = document.getElementById('game-duration');
      playerList.innerHTML = '';
      isHost = playerId === gameState.lobby.hostId;

      for (let id in gameState.lobby.players) {
        const player = gameState.lobby.players[id];
        const playerDiv = document.createElement('div');
        playerDiv.innerHTML = `<span>${player.name}${id === gameState.lobby.hostId ? ' (Host)' : ''}${player.spectating ? ' (Spectating)' : ''}</span><span>${player.ready ? 'Ready' : 'Not Ready'}</span>`;
        playerList.appendChild(playerDiv);
      }

      readyButton.style.display = isSpectating ? 'none' : 'block';
      readyButton.innerHTML = gameState.lobby.players[playerId]?.ready ? '<i class="fas fa-times"></i> Unready' : '<i class="fas fa-check"></i> Ready';
      startButton.disabled = !isHost || gameState.lobby.isGameStarted;
      spectateButton.style.display = isHost ? 'block' : 'none';
      spectateButton.innerHTML = gameState.lobby.players[playerId]?.spectating ? '<i class="fas fa-eye-slash"></i> Play' : '<i class="fas fa-eye"></i> Spectate';
      durationSelect.style.display = isHost && !gameState.lobby.isGameStarted ? 'block' : 'none';

      if (gameState.lobby.isGameStarted && gameState.lobby.countdown > 0) {
        document.getElementById('countdown').style.display = 'block';
        document.getElementById('countdown').textContent = gameState.lobby.countdown;
      } else {
        document.getElementById('countdown').style.display = 'none';
      }
    }

    function setupTouchControls() {
      let joystickDiv = document.getElementById('joystick');
      let skillButton = document.getElementById('skill-button');
      let lockButton = document.getElementById('lock-button');

      joystickDiv.addEventListener('touchstart', (e) => {
        e.preventDefault();
        joystick.active = true;
        let touch = e.touches[0];
        let rect = joystickDiv.getBoundingClientRect();
        joystick.baseX = window.innerWidth / 2;
        joystick.baseY = window.innerHeight - 100;
        joystickDiv.style.left = joystick.baseX + 'px';
        joystickDiv.style.top = joystick.baseY + 'px';
        updateJoystickPosition(touch, rect);
      });

      joystickDiv.addEventListener('touchmove', (e) => {
        e.preventDefault();
        let touch = e.touches[0];
        let rect = joystickDiv.getBoundingClientRect();
        updateJoystickPosition(touch, rect);
      });

      joystickDiv.addEventListener('touchend', () => {
        joystick.active = false;
        joystick.x = 0;
        joystick.y = 0;
        updateJoystick();
      });

      skillButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        let currentTime = Date.now();
        if (currentTime - lastTapTime < 300) {
          tapCount++;
          if (tapCount === 2) {
            if (gameMode === 'single' && !surgeActive && surgeCooldown <= 0) {
              surgeActive = true;
              surgeTimer = 180;
            } else if (gameMode === 'multi' && socket && isAlive && !isSpectating) {
              socket.emit('playerInput', { flushBoost: true });
            }
            tapCount = 0;
          }
        } else {
          tapCount = 1;
        }
        lastTapTime = currentTime;
      });

      lockButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        cameraLocked = !cameraLocked;
        lockButton.innerHTML = cameraLocked ? '<i class="fas fa-lock"></i> Unlock' : '<i class="fas fa-lock"></i> Lock';
      });
    }

    function updateJoystickPosition(touch, rect) {
      joystick.x = touch.clientX - rect.left - rect.width / 2;
      joystick.y = touch.clientY - rect.top - rect.height / 2;
      let dist = sqrt(joystick.x * joystick.x + joystick.y * joystick.y);
      if (dist > 25) {
        let angle = atan2(joystick.y, joystick.x);
        joystick.x = 25 * cos(angle);
        joystick.y = 25 * sin(angle);
      }
      updateJoystick();
    }

    function updateJoystick() {
      let knob = document.getElementById('joystick-knob');
      knob.style.left = (40 + joystick.x) + 'px';
      knob.style.top = (40 + joystick.y) + 'px';
    }

    function updateLeaderboard() {
      leaderboard = [];
      if (gameMode === 'single' && player) {
        leaderboard.push({ name: player.name, size: floor(player.r) });
        for (let bot of bots) {
          leaderboard.push({ name: bot.name, size: floor(bot.r) });
        }
        leaderboard.sort((a, b) => b.size - a.size);
        leaderboard = leaderboard.slice(0, 10);
      }
    }

    function drawLeaderboard() {
      push();
      let isMobile = windowWidth < 600;
      let boxWidth = isMobile ? 150 : 200;
      let boxHeight = isMobile ? 150 : 260;
      fill(0, 0, 50, 200);
      stroke(123, 104, 238);
      strokeWeight(2);
      rect(10, 10, boxWidth, boxHeight, 10);
      fill(123, 104, 238);
      textSize(isMobile ? 10 : 14);
      textAlign(LEFT);
      textStyle(NORMAL);
      textFont('Press Start 2P');
      text('AURA Leaderboard', 20, isMobile ? 25 : 35);
      fill(255);
      textSize(isMobile ? 8 : 12);
      if (gameMode === 'single') {
        for (let i = 0; i < leaderboard.length; i++) {
          text(`${i + 1}. ${leaderboard[i].name}: ${leaderboard[i].size}`, 20, (isMobile ? 45 : 60) + i * (isMobile ? 12 : 20));
        }
      } else if (Array.isArray(gameState.leaderboard)) {
        for (let i = 0; i < gameState.leaderboard.length; i++) {
          text(`${i + 1}. ${gameState.leaderboard[i].name}: ${gameState.leaderboard[i].size}`, 20, (isMobile ? 45 : 60) + i * (isMobile ? 12 : 20));
        }
      }
      pop();
    }

    function drawMinimap() {
      let miniWidth = 100;
      let miniHeight = 100;
      let scaleX = miniWidth / worldWidth;
      let scaleY = miniHeight / worldHeight;
      let isMobile = windowWidth < 768;

      push();
      if (isMobile) {
        translate(width - miniWidth - 10, 10);
      } else {
        translate(width - miniWidth - 10, height - miniHeight - 10);
      }

      fill(0, 0, 50, 200);
      stroke(123, 104, 238);
      strokeWeight(2);
      rect(0, 0, miniWidth, miniHeight, 5);

      fill(123, 104, 238);
      textSize(10);
      textFont('Press Start 2P');
      textAlign(LEFT);
      text('Cosmic Map', 5, 15);

      if (gameMode === 'single') {
        fill(75, 0, 130);
        noStroke();
        for (let zone of nebulaZones) {
          ellipse(zone.pos.x * scaleX, zone.pos.y * scaleY, zone.r * 2 * scaleX);
        }
        fill(255, 255, 0);
        for (let f of foods) {
          ellipse(f.pos.x * scaleX, f.pos.y * scaleY, f.r * 2 * scaleX);
        }
        fill(169, 169, 169);
        for (let vortex of vortexes) {
          ellipse(vortex.pos.x * scaleX, vortex.pos.y * scaleY, vortex.r * 2 * scaleX);
        }
        let [r, g, b] = hexToRgb(player.avatar.color);
        fill(r, g, b);
        ellipse(player.pos.x * scaleX, player.pos.y * scaleY, player.r * 2 * scaleX);
        for (let bot of bots) {
          let [br, bg, bb] = hexToRgb(bot.avatar.color);
          fill(br, bg, bb);
          ellipse(bot.pos.x * scaleX, bot.pos.y * scaleY, bot.r * 2 * scaleX);
        }
      } else {
        if (Array.isArray(gameState.clogZones)) {
          fill(75, 0, 130);
          noStroke();
          for (let zone of gameState.clogZones) {
            ellipse(zone.pos.x * scaleX, zone.pos.y * scaleY, zone.r * 2 * scaleX);
          }
        }
        if (Array.isArray(gameState.debris)) {
          fill(255, 255, 0);
          for (let d of gameState.debris) {
            ellipse(d.pos.x * scaleX, d.pos.y * scaleY, d.r * 2 * scaleX);
          }
        }
        if (Array.isArray(gameState.pipes)) {
          fill(169, 169, 169);
          for (let pipe of gameState.pipes) {
            ellipse(pipe.pos.x * scaleX, pipe.pos.y * scaleY, pipe.r * 2 * scaleX);
          }
        }
        if (gameState.players) {
          for (let id in gameState.players) {
            let p = gameState.players[id];
            if (p.spectating) continue;
            let [r, g, b] = hexToRgb(p.avatar.color);
            fill(r, g, b);
            ellipse(p.pos.x * scaleX, p.pos.y * scaleY, p.r * 2 * scaleX);
          }
        }
        if (Array.isArray(gameState.bots)) {
          for (let bot of gameState.bots) {
            let [r, g, b] = hexToRgb(bot.avatar.color);
            fill(r, g, b);
            ellipse(bot.pos.x * scaleX, bot.pos.y * scaleY, bot.r * 2 * scaleX);
          }
        }
      }
      pop();
    }

    function drawSurgeStatus() {
      if (isSpectating) return;
      push();
      let isMobile = windowWidth < 768;
      let boxWidth = isMobile ? 50 : 110;
      let boxHeight = isMobile ? 110 : 50;
      let x = isMobile ? width - boxWidth - 10 : width - boxWidth - 10;
      let y = isMobile ? height / 2 - boxHeight / 2 : 10;

      fill(0, 0, 50, 200);
      stroke(123, 104, 238);
      strokeWeight(2);
      rect(x, y, boxWidth, boxHeight, 10);

      let maxDuration = 180;
      let maxCooldown = 600;
      let progress = 1;

      if (gameMode === 'single') {
        if (surgeActive) {
          progress = surgeTimer / maxDuration;
        } else if (surgeCooldown > 0) {
          progress = 1 - (surgeCooldown / maxCooldown);
        }
      } else if (gameState.players && gameState.players[playerId]) {
        let player = gameState.players[playerId];
        if (player.flushBoostActive) {
          progress = player.flushBoostTimer / maxDuration;
        } else if (player.flushBoostCooldown > 0) {
          progress = 1 - (player.flushBoostCooldown / maxCooldown);
        }
      }

      if (isMobile) {
        let barX = x + 15;
        let barY = y + 15;
        let barWidth = 20;
        let barHeight = 80;
        noStroke();
        fill(80);
        rect(barX, barY, barWidth, barHeight, 5);
        let filledHeight = barHeight * progress;
        if (progress < 1 && progress > 0) {
          fill(255, 87, 34);
        } else {
          fill(123, 104, 238);
        }
        rect(barX, barY + (barHeight - filledHeight), barWidth, filledHeight, 5);
        fill(123, 104, 238);
        textSize(10);
        textFont('Press Start 2P');
        textAlign(CENTER);
        text('SURGE', x + boxWidth / 2, y + 10);
      } else {
        let barX = x + 15;
        let barY = y + 30;
        let barWidth = 80;
        let barHeight = 10;
        noStroke();
        fill(80);
        rect(barX, barY, barWidth, barHeight, 5);
        if (progress < 1 && progress > 0) {
          fill(255, 87, 34);
        } else {
          fill(123, 104, 238);
        }
        rect(barX, barY, barWidth * progress, barHeight, 5);
        fill(123, 104, 238);
        textSize(10);
        textFont('Press Start 2P');
        textAlign(CENTER);
        text('SURGE', x + boxWidth / 2, y + 15);
      }
      pop();
    }

    function drawAbsorbStatus() {
      if (isSpectating) return;
      if (absorbTimer > 0) {
        push();
        let isMobile = windowWidth < 768;
        let boxWidth = isMobile ? 50 : 110;
        let boxHeight = isMobile ? 50 : 50;
        let x = isMobile ? width - boxWidth - 10 : width - boxWidth - 10;
        let y = isMobile ? height / 2 + 70 : 70;

        fill(0, 0, 50, 200);
        stroke(123, 104, 238);
        strokeWeight(2);
        rect(x, y, boxWidth, boxHeight, 10);

        let maxAbsorbTime = 600;
        let progress = absorbTimer / maxAbsorbTime;

        if (isMobile) {
          let barX = x + 15;
          let barY = y + 15;
          let barWidth = 20;
          let barHeight = 20;
          noStroke();
          fill(80);
          rect(barX, barY, barWidth, barHeight, 5);
          fill(255, 87, 34);
          rect(barX, barY, barWidth * progress, barHeight, 5);
          fill(123, 104, 238);
          textSize(10);
          textFont('Press Start 2P');
          textAlign(CENTER);
          text('ABSORB', x + boxWidth / 2, y + 10);
        } else {
          let barX = x + 15;
          let barY = y + 30;
          let barWidth = 80;
          let barHeight = 10;
          noStroke();
          fill(80);
          rect(barX, barY, barWidth, barHeight, 5);
          fill(255, 87, 34);
          rect(barX, barY, barWidth * progress, barHeight, 5);
          fill(123, 104, 238);
          textSize(10);
          textFont('Press Start 2P');
          textAlign(CENTER);
          text('ABSORB', x + boxWidth / 2, y + 15);
        }
        pop();
      }
    }

    class AuraOrb {
      constructor(x, y, r, isPlayer) {
        this.pos = createVector(x, y);
        this.r = r;
        this.vel = createVector(0, 0);
        this.isPlayer = isPlayer;
        this.target = isPlayer ? null : createVector(random(worldWidth), random(worldHeight));
        this.name = "";
        this.inNebulaZone = false;
        this.avatar = isPlayer ? avatar : { color: '#E6E6FA', accessory: '✨' };
        this.flushBoostActive = false;
        this.flushBoostTimer = 0;
        this.flushBoostCooldown = 0;
      }

      update() {
        let speedMultiplier = this.inNebulaZone ? 0.5 : 1;
        if (this.isPlayer && surgeActive) {
          speedMultiplier *= 3.8;
        }
        if (this.isPlayer) {
          let dir;
          if (isMobile && joystick.active) {
            dir = createVector(joystick.x * 6, joystick.y * 6);
          } else if (!cameraLocked) {
            let mouse = createVector(mouseX + cameraX, mouseY + cameraY);
            dir = p5.Vector.sub(mouse, this.pos);
          } else {
            dir = createVector(0, 0);
          }
          dir.setMag(3.6 * speedMultiplier / sqrt(this.r));
          this.vel.lerp(dir, 0.1);
        } else {
          let nearest = this.findNearestCollectible();
          if (nearest && p5.Vector.dist(this.pos, nearest.pos) < 200) {
            this.target = nearest.pos;
          } else if (p5.Vector.dist(this.pos, this.target) < 50) {
            this.target = createVector(random(worldWidth), random(worldHeight));
          }
          let dir = p5.Vector.sub(this.target, this.pos);
          dir.setMag(2 * speedMultiplier / sqrt(this.r));
          this.vel.lerp(dir, 0.05);
        }
        this.pos.add(this.vel);
        this.pos.x = constrain(this.pos.x, this.r, worldWidth - this.r);
        this.pos.y = constrain(this.pos.y, this.r, worldHeight - this.r);
      }

      findNearestCollectible() {
        let nearest = null;
        let minDist = Infinity;
        let collectibles = gameMode === 'single' ? [...stardust, ...foods] : [
          ...(Array.isArray(gameState.debris) ? gameState.debris : [])
        ];
        for (let c of collectibles) {
          let dist = p5.Vector.dist(this.pos, c.pos);
          if (dist < minDist) {
            minDist = dist;
            nearest = c;
          }
        }
        return nearest;
      }

      show() {
        let isHidden = false;
        let vortexArray = gameMode === 'single' ? vortexes : (Array.isArray(gameState.pipes) ? gameState.pipes : []);
        for (let vortex of vortexArray) {
          if (p5.Vector.dist(this.pos, vortex.pos) < vortex.r + this.r) {
            isHidden = true;
            break;
          }
        }
        push();
        let [r, g, b] = hexToRgb(this.avatar.color);
        fill(r, g, b, isHidden ? 100 : 255);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
        if (this.isPlayer) {
          for (let i = 0; i < 50; i++) {
            let angle = random(TWO_PI);
            let dist = random(this.r, this.r * 1.2);
            let x = this.pos.x + cos(angle) * dist;
            let y = this.pos.y + sin(angle) * dist;
            fill(r * 0.8, g * 0.8, b * 0.8, isHidden ? 50 : 200);
            ellipse(x, y, 3);
          }
        }
        fill(255, 255, 255, isHidden ? 100 : 255);
        textAlign(CENTER, CENTER);
        textSize(this.r * 1.2);
        textStyle(BOLD);
        text(this.avatar.accessory, this.pos.x, this.pos.y);
        fill(255, 255, 255, isHidden ? 100 : 255);
        textAlign(CENTER);
        textSize(12);
        text(this.name, this.pos.x, this.pos.y - this.r - 10);
        pop();
      }

      clears(collectible) {
        let d = p5.Vector.dist(this.pos, collectible.pos);
        if (d < this.r + collectible.r) {
          let area = PI * this.r * this.r + PI * collectible.r * collectible.r;
          this.r = sqrt(area / PI);
          return true;
        }
        return false;
      }

      clearsFood(food) {
        let d = p5.Vector.dist(this.pos, food.pos);
        if (d < this.r + food.r) {
          let area = PI * this.r * this.r + PI * 2 * 2;
          this.r = sqrt(area / PI);
          return true;
        }
        return false;
      }

      canClear(other) {
        let d = p5.Vector.dist(this.pos, other.pos);
        return this.r > other.r * 1.1 && d < this.r + other.r;
      }

      clearAuraOrb(other) {
        let area = PI * this.r * this.r + PI * other.r * other.r;
        this.r = sqrt(area / PI);
      }
    }

    class Stardust {
      constructor(x, y) {
        this.pos = createVector(x || random(worldWidth), y || random(worldHeight));
        this.r = 5;
      }

      show() {
        fill(75, 0, 130);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
      }
    }

    class Food {
      constructor(x, y) {
        this.pos = createVector(x || random(worldWidth), y || random(worldHeight));
        this.r = 3;
      }

      show() {
        fill(255, 255, 0);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
      }
    }

    class Vortex {
      constructor() {
        this.pos = createVector(random(worldWidth), random(worldHeight));
        this.r = 30;
      }

      show() {
        fill(169, 169, 169);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
      }
    }

    class NebulaZone {
      constructor() {
        this.pos = createVector(random(worldWidth), random(worldHeight));
        this.r = 100;
        this.spawnTimer = 0;
      }

      update() {
        this.spawnTimer++;
        if (this.spawnTimer >= 60) {
          let targetStardust = gameMode === 'single' ? stardust : (Array.isArray(gameState.debris) ? gameState.debris : []);
          let targetFoods = gameMode === 'single' ? foods : (Array.isArray(gameState.debris) ? gameState.debris : []);
          targetStardust.push(new Stardust(this.pos.x + random(-this.r, this.r), this.pos.y + random(-this.r, this.r)));
          targetFoods.push(new Food(this.pos.x + random(-this.r, this.r), this.pos.y + random(-this.r, this.r)));
          this.spawnTimer = 0;
        }
      }

      show() {
        push();
        fill(75, 0, 130, 150);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
        fill(123, 104, 238, 100);
        ellipse(this.pos.x, this.pos.y, this.r * 1.5);
        pop();
      }
    }

    function safeStorageAccess(key, value) {
      try {
        if (value !== undefined) {
          localStorage.setItem(key, value);
        } else {
          return localStorage.getItem(key);
        }
      } catch (e) {
        console.warn('Storage access failed:', e.message);
        return null;
      }
    }
  </script>
</body>
</html>