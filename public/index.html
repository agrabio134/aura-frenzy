<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>$AURA Frenzy</title>
  <link rel="icon" type="image/png" href="aura.jpg">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: radial-gradient(circle, #2a1a5e, #0d0b2f);
      overflow: hidden;
      font-family: 'Press Start 2P', cursive;
    }
    canvas {
      display: none;
      width: 100vw !important;
      height: 100vh !important;
    }
    #menu, #mode-selection, #name-input, #avatar-menu, #nft-marketplace {
      text-align: center;
      padding: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 3px solid #7b68ee;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(123, 104, 238, 0.5);
      max-width: 500px;
      width: 90%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #menu h1, #mode-selection h1, #name-input h1, #avatar-menu h1, #nft-marketplace h1 {
      font-size: 32px;
      color: #7b68ee;
      text-shadow: 0 0 10px #7b68ee, 0 0 20px #7b68ee;
      margin-bottom: 40px;
      letter-spacing: 2px;
    }
    #nft-marketplace p {
      color: #fff;
      font-size: 16px;
      margin-bottom: 20px;
    }
    #menu .button-container, #mode-selection .button-container, #name-input .button-container, #avatar-menu .button-container, #nft-marketplace .button-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    #menu button, #mode-selection button, #name-input button, #avatar-menu button, #nft-marketplace button {
      padding: 15px 30px;
      font-size: 16px;
      font-family: 'Press Start 2P', cursive;
      color: #fff;
      border: 2px solid #7b68ee;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    #menu button.play, #mode-selection button.play, #name-input button.play, #avatar-menu button.play, #nft-marketplace button.play {
      background: linear-gradient(45deg, #7b68ee, #483d8b);
    }
    #menu button.play:hover, #mode-selection button.play:hover, #name-input button.play:hover, #avatar-menu button.play:hover, #nft-marketplace button.play:hover {
      background: linear-gradient(45deg, #6a5acd, #3c2f6b);
      box-shadow: 0 0 15px #7b68ee;
      transform: scale(1.05);
    }
    #menu button:disabled, #mode-selection button:disabled, #name-input button:disabled, #avatar-menu button:disabled, #nft-marketplace button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #name-input input {
      padding: 10px;
      font-size: 16px;
      font-family: 'Press Start 2P', cursive;
      color: #7b68ee;
      background: #2a1a5e;
      border: 2px solid #7b68ee;
      border-radius: 5px;
      width: 80%;
      margin-bottom: 20px;
      text-align: center;
    }
    #avatar-menu .options {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    #avatar-menu .option {
      padding: 10px;
      border: 2px solid #7b68ee;
      border-radius: 5px;
      cursor: pointer;
      background: #2a1a5e;
      color: #fff;
      font-size: 14px;
    }
    #avatar-menu .option.selected {
      background: #7b68ee;
      color: #000;
    }
    #avatar-menu .preview {
      width: 100px;
      height: 100px;
      margin: 20px auto;
      border: 2px solid #7b68ee;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      background-image: url('aura.jpg');
      background-size: cover;
      background-position: center;
    }
    #joystick {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 100px;
      height: 100px;
      background: rgba(123, 104, 238, 0.3);
      border: 2px solid #7b68ee;
      border-radius: 50%;
      display: none;
      box-shadow: 0 0 10px rgba(123, 104, 238, 0.5);
    }
    #joystick-knob {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #7b68ee;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px #7b68ee;
    }
    #skill-button, #lock-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      background: linear-gradient(45deg, #ff4500, #d83b01);
      border: 2px solid #7b68ee;
      border-radius: 50%;
      color: #fff;
      text-align: center;
      line-height: 60px;
      font-size: 12px;
      font-family: 'Press Start 2P', cursive;
      display: none;
      box-shadow: 0 0 10px #ff4500;
    }
    #lock-button {
      bottom: 90px;
    }
    @media (max-width: 600px) {
      #menu, #mode-selection, #name-input, #avatar-menu, #nft-marketplace {
        padding: 15px;
      }
      #menu h1, #mode-selection h1, #name-input h1, #avatar-menu h1, #nft-marketplace h1 {
        font-size: 24px;
        margin-bottom: 30px;
      }
      #menu button, #mode-selection button, #name-input button, #avatar-menu button, #nft-marketplace button {
        font-size: 14px;
        padding: 12px 25px;
      }
      #joystick, #skill-button, #lock-button {
        display: block;
      }
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>$AURA FRENZY</h1>
    <div class="button-container">
      <button class="play" onclick="showModeSelection()"><i class="fas fa-play"></i> Play</button>
      <button class="play" onclick="showAvatarMenu()"><i class="fas fa-paint-brush"></i> Avatar</button>
      <button class="play" onclick="showNFTMarketplace()"><i class="fas fa-shopping-cart"></i> NFT Marketplace</button>
      <button class="play" onclick="showLeaderboard()"><i class="fas fa-trophy"></i> AURA Leaderboard</button>
    </div>
  </div>
  <div id="mode-selection" style="display: none;">
    <h1>SELECT MODE</h1>
    <div class="button-container">
      <button class="play" onclick="showNameInput('single')"><i class="fas fa-user"></i> Single Player</button>
<button class="play" disabled title="Multiplayer is locked" style="opacity: 0.6; cursor: not-allowed;">
  <i class="fas fa-lock"></i> Multiplayer Locked
</button>
    </div>
  </div>
  <div id="name-input" style="display: none;">
    <h1>ENTER NAME</h1>
    <input type="text" id="player-name" maxlength="12" placeholder="Your Name">
    <div class="button-container">
      <button class="play" onclick="startGame()"><i class="fas fa-play"></i> Start Game</button>
    </div>
  </div>
  <div id="avatar-menu" style="display: none;">
    <h1>CUSTOMIZE AVATAR</h1>
    <div class="options" id="color-options">
      <h3 style="color: #7b68ee; width: 100%;">Aura Color</h3>
      <div class="option" data-color="#E6E6FA">Cosmic Lavender</div>
      <div class="option" data-color="#7B68EE">Nebula Purple</div>
      <div class="option" data-color="#00CED1">Stellar Cyan</div>
    </div>
    <div class="options" id="accessory-options">
      <h3 style="color: #7b68ee; width: 100%;">Aura Symbol</h3>
      <div class="option" data-accessory="âœ¨">Cosmic Spark</div>
      <div class="option" data-accessory="ðŸŒŒ">Nebula Swirl</div>
      <div class="option" data-accessory="ðŸ”®">Mystic Rune</div>
    </div>
    <div class="preview" id="avatar-preview"></div>
    <div class="button-container">
      <button class="play" onclick="saveAvatar()"><i class="fas fa-save"></i> Save Avatar</button>
      <button class="play" onclick="returnToMenu()"><i class="fas fa-arrow-left"></i> Back</button>
    </div>
  </div>
  <div id="nft-marketplace" style="display: none;">
    <h1>NFT MARKETPLACE</h1>
    <p style="color: #fff !important;">Explore and purchase unique Aura NFTs!</p>
    <div class="button-container">
      <button class="play" disabled title="Marketplace is locked" style="opacity: 0.6; cursor: not-allowed;">
        <i class="fas fa-lock"></i> Marketplace Locked
      </button>
      <button class="play" onclick="returnToMenu()"><i class="fas fa-arrow-left"></i> Back</button>
    </div>
  </div>
  <div id="joystick">
    <div id="joystick-knob"></div>
  </div>
  <div id="skill-button"><i class="fas fa-bolt"></i> Surge</div>
  <div id="lock-button"><i class="fas fa-lock"></i> Lock</div>
  <script>
    let socket;
    let gameStarted = false;
    let gameMode = null;
    let playerName = '';
    let worldWidth = 4000;
    let worldHeight = 4000;
    let cameraX = 0;
    let cameraY = 0;
    let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    let joystick = { active: false, x: 0, y: 0, baseX: 70, baseY: window.innerHeight - 70 };
    let playerId = null;
    let isAlive = true;
    let cameraLocked = false;

    // Avatar settings
    let avatar = {
      color: safeStorageAccess('avatarColor') || '#E6E6FA',
      accessory: safeStorageAccess('avatarAccessory') || 'âœ¨'
    };

    // Single-player state
    let player;
    let bots = [];
    let stardust = [];
    let foods = [];
    let vortexes = [];
    let nebulaZones = [];
    let botNames = ["Star", "Nebula", "Pulse", "Glow", "Cosmo", "Flare"];
    let leaderboard = [];
    let surgeActive = false;
    let surgeCooldown = 0;
    let surgeTimer = 0;
    let absorbTimer = 0;

    // Multiplayer state
    let gameState = { players: {}, bots: [], stardust: [], foods: [], vortexes: [], nebulaZones: [], leaderboard: [] };

    function setup() {
      if (gameStarted) {
        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        createCanvas(canvasWidth, canvasHeight);
        if (gameMode === 'single') {
          player = new AuraOrb(worldWidth / 2, worldHeight / 2, 10, true);
          player.name = playerName || 'Starfarer';
          player.avatar = avatar;
          for (let i = 0; i < 10; i++) {
            let bot = new AuraOrb(random(worldWidth), random(worldHeight), 10, false);
            bot.name = botNames[i % botNames.length] + i;
            bot.avatar = {
              color: random(['#E6E6FA', '#7B68EE', '#00CED1']),
              accessory: random(['âœ¨', 'ðŸŒŒ', 'ðŸ”®'])
            };
            bots.push(bot);
          }
          for (let i = 0; i < 1000; i++) {
            stardust.push(new Stardust());
            foods.push(new Food());
          }
          for (let i = 0; i < 20; i++) {
            vortexes.push(new Vortex());
          }
          for (let i = 0; i < 5; i++) {
            nebulaZones.push(new NebulaZone());
          }
        } else if (gameMode === 'multi') {
          if (!Array.isArray(gameState.nebulaZones)) {
            gameState.nebulaZones = [];
            for (let i = 0; i < 5; i++) {
              gameState.nebulaZones.push(new NebulaZone());
            }
          }
          if (!Array.isArray(gameState.stardust)) {
            gameState.stardust = [];
            for (let i = 0; i < 1000; i++) {
              gameState.stardust.push(new Stardust());
            }
          }
          if (!Array.isArray(gameState.foods)) {
            gameState.foods = [];
            for (let i = 0; i < 1000; i++) {
              gameState.foods.push(new Food());
            }
            console.log('Initialized fallback foods:', gameState.foods.length);
          }
          if (!Array.isArray(gameState.vortexes)) {
            gameState.vortexes = [];
            for (let i = 0; i < 20; i++) {
              gameState.vortexes.push(new Vortex());
            }
          }
          if (!Array.isArray(gameState.bots)) {
            gameState.bots = [];
            for (let i = 0; i < 10; i++) {
              let bot = new AuraOrb(random(worldWidth), random(worldHeight), 10, false);
              bot.name = botNames[i % botNames.length] + i;
              bot.avatar = {
                color: random(['#E6E6FA', '#7B68EE', '#00CED1']),
                accessory: random(['âœ¨', 'ðŸŒŒ', 'ðŸ”®'])
              };
              gameState.bots.push(bot);
            }
          }
        }
        if (isMobile) {
          setupTouchControls();
        }
      }
    }

    function draw() {
      if (gameStarted && isAlive) {
        if (gameMode === 'single') {
          if (surgeActive) {
            surgeTimer--;
            if (surgeTimer <= 0) {
              surgeActive = false;
              surgeCooldown = 600;
            }
          } else if (surgeCooldown > 0) {
            surgeCooldown--;
          }

          if (!cameraLocked) {
            cameraX = lerp(cameraX, player.pos.x - width / 2, 0.1);
            cameraY = lerp(cameraY, player.pos.y - height / 2, 0.1);
          } else {
            cameraX = player.pos.x - width / 2;
            cameraY = player.pos.y - height / 2;
          }

          background(10, 15, 50);
          push();
          translate(-cameraX, -cameraY);
          stroke(50, 60, 120);
          strokeWeight(1);
          for (let x = 0; x < worldWidth; x += 50) {
            line(x, 0, x, worldHeight);
          }
          for (let y = 0; y < worldHeight; y += 50) {
            line(0, y, worldWidth, y);
          }

          stroke(123, 104, 238);
          strokeWeight(3);
          noFill();
          rect(0, 0, worldWidth, worldHeight);

          for (let zone of nebulaZones) {
            zone.show();
            zone.update();
          }

          for (let d of stardust) {
            d.show();
          }

          for (let f of foods) {
            f.show();
          }

          for (let vortex of vortexes) {
            vortex.show();
          }

          let inNebulaZone = false;
          for (let zone of nebulaZones) {
            if (p5.Vector.dist(player.pos, zone.pos) < zone.r) {
              inNebulaZone = true;
              absorbTimer++;
              if (absorbTimer >= 600) {
                player.r += 10;
                nebulaZones.splice(nebulaZones.indexOf(zone), 1);
                nebulaZones.push(new NebulaZone());
                absorbTimer = 0;
              }
              break;
            }
          }
          if (!inNebulaZone) absorbTimer = 0;

          player.inNebulaZone = inNebulaZone;
          player.update();
          player.show();

          for (let bot of bots) {
            let botInNebulaZone = false;
            for (let zone of nebulaZones) {
              if (p5.Vector.dist(bot.pos, zone.pos) < zone.r) {
                botInNebulaZone = true;
                break;
              }
            }
            bot.inNebulaZone = botInNebulaZone;
            bot.update();
            bot.show();
          }

          for (let i = stardust.length - 1; i >= 0; i--) {
            if (player.clears(stardust[i])) {
              stardust.splice(i, 1);
              stardust.push(new Stardust());
            }
          }

          for (let i = foods.length - 1; i >= 0; i--) {
            if (player.clearsFood(foods[i])) {
              foods.splice(i, 1);
              foods.push(new Food());
            }
          }

          for (let bot of bots) {
            for (let i = stardust.length - 1; i >= 0; i--) {
              if (bot.clears(stardust[i])) {
                stardust.splice(i, 1);
                stardust.push(new Stardust());
              }
            }
            for (let i = foods.length - 1; i >= 0; i--) {
              if (bot.clearsFood(foods[i])) {
                foods.splice(i, 1);
                foods.push(new Food());
              }
            }
          }

          for (let i = bots.length - 1; i >= 0; i--) {
            if (player.canClear(bots[i])) {
              player.clearAuraOrb(bots[i]);
              bots.splice(i, 1);
              let newBot = new AuraOrb(random(worldWidth), random(worldHeight), 10, false);
              newBot.name = botNames[i % botNames.length] + i;
              newBot.avatar = {
                color: random(['#E6E6FA', '#7B68EE', '#00CED1']),
                accessory: random(['âœ¨', 'ðŸŒŒ', 'ðŸ”®'])
              };
              bots.push(newBot);
            } else if (bots[i].canClear(player)) {
              isAlive = false;
              gameStarted = false;
              if (socket) {
                socket.disconnect();
                socket = null;
              }
              remove();
              location.reload();
              return;
            }
          }

          for (let i = bots.length - 1; i >= 0; i--) {
            for (let j = bots.length - 1; j >= 0; j--) {
              if (i !== j && bots[i].canClear(bots[j])) {
                bots[i].clearAuraOrb(bots[j]);
                bots.splice(j, 1);
                let newBot = new AuraOrb(random(worldWidth), random(worldHeight), 10, false);
                newBot.name = botNames[j % botNames.length] + j;
                newBot.avatar = {
                  color: random(['#E6E6FA', '#7B68EE', '#00CED1']),
                  accessory: random(['âœ¨', 'ðŸŒŒ', 'ðŸ”®'])
                };
                bots.push(newBot);
              }
            }
          }

          pop();

          updateLeaderboard();
          drawLeaderboard();
          drawMinimap();
          drawSurgeStatus();
          drawAbsorbStatus();
        } else {
          if (!gameState.players[playerId] || !isAlive) {
            return;
          }

          if (!cameraLocked) {
            cameraX = lerp(cameraX, gameState.players[playerId].pos.x - width / 2, 0.1);
            cameraY = lerp(cameraY, gameState.players[playerId].pos.y - height / 2, 0.1);
          } else {
            cameraX = gameState.players[playerId].pos.x - width / 2;
            cameraY = gameState.players[playerId].pos.y - height / 2;
          }

          background(10, 15, 50);
          push();
          translate(-cameraX, -cameraY);
          stroke(50, 60, 120);
          strokeWeight(1);
          for (let x = 0; x < worldWidth; x += 50) {
            line(x, 0, x, worldHeight);
          }
          for (let y = 0; y < worldHeight; y += 50) {
            line(0, y, worldWidth, y);
          }

          stroke(123, 104, 238);
          strokeWeight(3);
          noFill();
          rect(0, 0, worldWidth, worldHeight);

          if (Array.isArray(gameState.nebulaZones)) {
            for (let zone of gameState.nebulaZones) {
              fill(75, 0, 130, 150);
              noStroke();
              ellipse(zone.pos.x, zone.pos.y, zone.r * 2);
              fill(123, 104, 238, 100);
              ellipse(zone.pos.x, zone.pos.y, zone.r * 1.5);
            }
          }

          if (Array.isArray(gameState.stardust)) {
            for (let d of gameState.stardust) {
              fill(75, 0, 130);
              noStroke();
              ellipse(d.pos.x, d.pos.y, d.r * 2);
            }
          }

          if (Array.isArray(gameState.foods)) {
            for (let f of gameState.foods) {
              fill(255, 255, 0);
              noStroke();
              ellipse(f.pos.x, f.pos.y, f.r * 2);
            }
          }

          if (Array.isArray(gameState.vortexes)) {
            for (let vortex of gameState.vortexes) {
              fill(169, 169, 169);
              noStroke();
              ellipse(vortex.pos.x, vortex.pos.y, vortex.r * 2);
            }
          }

          if (gameState.players) {
            for (let id in gameState.players) {
              let player = gameState.players[id];
              let isHidden = false;
              if (Array.isArray(gameState.vortexes)) {
                for (let vortex of gameState.vortexes) {
                  let d = dist(player.pos.x, player.pos.y, vortex.pos.x, vortex.pos.y);
                  if (d < vortex.r + player.r) {
                    isHidden = true;
                    break;
                  }
                }
              }
              let [r, g, b] = hexToRgb(player.avatar.color);
              fill(r, g, b, isHidden ? 100 : 255);
              noStroke();
              ellipse(player.pos.x, player.pos.y, player.r * 2);
              for (let i = 0; i < 50; i++) {
                let angle = random(TWO_PI);
                let dist = random(player.r, player.r * 1.2);
                let x = player.pos.x + cos(angle) * dist;
                let y = player.pos.y + sin(angle) * dist;
                fill(r * 0.8, g * 0.8, b * 0.8, isHidden ? 50 : 200);
                ellipse(x, y, 3);
              }
              fill(255, 255, 255, isHidden ? 100 : 255);
              textAlign(CENTER, CENTER);
              textSize(player.r * 1.2);
              textStyle(BOLD);
              text(player.avatar.accessory, player.pos.x, player.pos.y);
              fill(255, 255, 255, isHidden ? 100 : 255);
              textAlign(CENTER);
              textSize(12);
              text(player.name, player.pos.x, player.pos.y - player.r - 10);
            }
          }

          if (Array.isArray(gameState.bots)) {
            for (let bot of gameState.bots) {
              let isHidden = false;
              if (Array.isArray(gameState.vortexes)) {
                for (let vortex of gameState.vortexes) {
                  let d = dist(bot.pos.x, bot.pos.y, vortex.pos.x, vortex.pos.y);
                  if (d < vortex.r + bot.r) {
                    isHidden = true;
                    break;
                  }
                }
              }
              let [r, g, b] = hexToRgb(bot.avatar.color);
              fill(r, g, b, isHidden ? 100 : 255);
              noStroke();
              ellipse(bot.pos.x, bot.pos.y, bot.r * 2);
              fill(255, 255, 255, isHidden ? 100 : 255);
              textAlign(CENTER, CENTER);
              textSize(bot.r * 1.2);
              text(bot.avatar.accessory, bot.pos.x, bot.pos.y);
              textAlign(CENTER);
              textSize(12);
              text(bot.name, bot.pos.x, bot.pos.y - bot.r - 10);
            }
          }

          if (Array.isArray(gameState.foods) && gameState.players[playerId]) {
            let currentPlayer = gameState.players[playerId];
            for (let i = gameState.foods.length - 1; i >= 0; i--) {
              let food = gameState.foods[i];
              let d = dist(currentPlayer.pos.x, currentPlayer.pos.y, food.pos.x, food.pos.y);
              if (d < currentPlayer.r + food.r) {
                socket.emit('collectFood', { index: i });
              }
            }
          }

          if (Array.isArray(gameState.stardust) && gameState.players[playerId]) {
            let currentPlayer = gameState.players[playerId];
            for (let i = gameState.stardust.length - 1; i >= 0; i--) {
              let stardust = gameState.stardust[i];
              let d = dist(currentPlayer.pos.x, currentPlayer.pos.y, stardust.pos.x, stardust.pos.y);
              if (d < currentPlayer.r + stardust.r) {
                socket.emit('collectStardust', { index: i });
              }
            }
          }

          pop();

          drawLeaderboard();
          drawMinimap();
          drawSurgeStatus();
          drawAbsorbStatus();

          if (isMobile && joystick.active) {
            updateJoystick();
          }

          let input = {};
          if (isMobile && joystick.active) {
            input.joystick = { x: joystick.x, y: joystick.y };
          } else if (!cameraLocked) {
            input.mouse = { x: mouseX + cameraX, y: mouseY + cameraY };
          }
          if (socket && isAlive) {
            socket.emit('playerInput', input);
          }
        }
      }
    }

    function hexToRgb(hex) {
      hex = hex.replace('#', '');
      let r = parseInt(hex.substring(0, 2), 16);
      let g = parseInt(hex.substring(2, 4), 16);
      let b = parseInt(hex.substring(4, 6), 16);
      return [r, g, b];
    }

    function keyPressed() {
      if (keyCode === 32 && isAlive) {
        if (gameMode === 'single' && !surgeActive && surgeCooldown <= 0) {
          surgeActive = true;
          surgeTimer = 180;
        } else if (gameMode === 'multi' && socket) {
          socket.emit('playerInput', { surge: true });
        }
      } else if (keyCode === 76) {
        cameraLocked = !cameraLocked;
        document.getElementById('lock-button').innerHTML = cameraLocked ? '<i class="fas fa-lock"></i> Unlock' : '<i class="fas fa-lock"></i> Lock';
      }
    }

    function showModeSelection() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('mode-selection').style.display = 'block';
      document.getElementById('name-input').style.display = 'none';
      document.getElementById('avatar-menu').style.display = 'none';
      document.getElementById('nft-marketplace').style.display = 'none';
    }

    function showNameInput(mode) {
      gameMode = mode;
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('name-input').style.display = 'block';
      document.getElementById('player-name').focus();
    }

    function showAvatarMenu() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('avatar-menu').style.display = 'block';
      setupAvatarMenu();
    }

    function showNFTMarketplace() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('nft-marketplace').style.display = 'block';
    }

    function showLeaderboard() {
      document.getElementById('menu').style.display = 'block';
      document.getElementById('nft-marketplace').style.display = 'none';
      document.getElementById('avatar-menu').style.display = 'none';
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('name-input').style.display = 'none';
    }

    function setupAvatarMenu() {
      let colorOptions = document.getElementById('color-options').getElementsByClassName('option');
      let accessoryOptions = document.getElementById('accessory-options').getElementsByClassName('option');
      let preview = document.getElementById('avatar-preview');

      for (let option of colorOptions) {
        option.classList.remove('selected');
        if (option.dataset.color === avatar.color) {
          option.classList.add('selected');
        }
        option.onclick = () => {
          avatar.color = option.dataset.color;
          for (let o of colorOptions) o.classList.remove('selected');
          option.classList.add('selected');
          updateAvatarPreview();
        };
      }

      for (let option of accessoryOptions) {
        option.classList.remove('selected');
        if (option.dataset.accessory === avatar.accessory) {
          option.classList.add('selected');
        }
        option.onclick = () => {
          avatar.accessory = option.dataset.accessory;
          for (let o of accessoryOptions) o.classList.remove('selected');
          option.classList.add('selected');
          updateAvatarPreview();
        };
      }

      updateAvatarPreview();
    }

    function updateAvatarPreview() {
      let preview = document.getElementById('avatar-preview');
      preview.style.backgroundColor = avatar.color;
      preview.textContent = avatar.accessory;
    }

    function saveAvatar() {
      safeStorageAccess('avatarColor', avatar.color);
      safeStorageAccess('avatarAccessory', avatar.accessory);
      location.reload();
    }

    function returnToMenu() {
      gameStarted = false;
      isAlive = true;
      playerId = null;
      gameState = { players: {}, bots: [], stardust: [], foods: [], vortexes: [], nebulaZones: [], leaderboard: [] };
      const canvas = document.querySelector('canvas');
      if (canvas) {
        canvas.style.display = 'none';
      }
      document.getElementById('menu').style.display = 'block';
      document.getElementById('mode-selection').style.display = 'none';
      document.getElementById('name-input').style.display = 'none';
      document.getElementById('avatar-menu').style.display = 'none';
      document.getElementById('nft-marketplace').style.display = 'none';
      if (gameMode === 'multi' && socket) {
        socket.disconnect();
        socket = null;
      }
      remove();
    }

    window.startGame = function() {
      playerName = document.getElementById('player-name').value.trim();
      if (playerName.length > 12) playerName = playerName.slice(0, 12);
      if (!playerName) playerName = 'Starfarer';
      document.getElementById('name-input').style.display = 'none';
      const canvas = document.querySelector('canvas');
      if (canvas) {
        canvas.style.display = 'block';
      }
      gameStarted = true;
      isAlive = true;
      setup();
      if (gameMode === 'multi') {
        socket = io();
        socket.on('connect', () => {
          console.log('Connected to server with ID:', socket.id);
          playerId = socket.id;
          socket.emit('playerJoin', { name: playerName, avatar, r: 10 });
        });
        socket.on('gameState', (state) => {
          console.log('Received gameState:', state);
          if (isAlive && state.players && state.players[playerId]) {
            state.nebulaZones = Array.isArray(state.nebulaZones) ? state.nebulaZones : [];
            state.stardust = Array.isArray(state.stardust) ? state.stardust : [];
            state.foods = Array.isArray(state.foods) ? state.foods : [];
            state.vortexes = Array.isArray(state.vortexes) ? state.vortexes : [];
            state.bots = Array.isArray(state.bots) ? state.bots : [];
            state.leaderboard = Array.isArray(state.leaderboard) ? state.leaderboard : [];
            gameState = state;
          }
        });
        socket.on('flushed', (data) => {
          console.log('Flushed event received:', data);
          isAlive = false;
          gameStarted = false;
          playerId = null;
          gameState = { players: {}, bots: [], stardust: [], foods: [], vortexes: [], nebulaZones: [], leaderboard: [] };
          if (socket) {
            socket.disconnect();
            socket = null;
          }
          remove();
          location.reload();
        });
        socket.on('connect_error', (error) => {
          console.error('Socket.IO connection error:', error);
          gameStarted = false;
          isAlive = false;
          if (socket) {
            socket.disconnect();
            socket = null;
          }
          remove();
          location.reload();
        });
      }
    };

    function setupTouchControls() {
      let joystickDiv = document.getElementById('joystick');
      let skillButton = document.getElementById('skill-button');
      let lockButton = document.getElementById('lock-button');

      joystickDiv.addEventListener('touchstart', (e) => {
        e.preventDefault();
        joystick.active = true;
      });

      joystickDiv.addEventListener('touchmove', (e) => {
        e.preventDefault();
        let touch = e.touches[0];
        let rect = joystickDiv.getBoundingClientRect();
        joystick.x = touch.clientX - rect.left - 50;
        joystick.y = touch.clientY - rect.top - 50;
        let dist = sqrt(joystick.x * joystick.x + joystick.y * joystick.y);
        if (dist > 30) {
          let angle = atan2(joystick.y, joystick.x);
          joystick.x = 30 * cos(angle);
          joystick.y = 30 * sin(angle);
        }
      });

      joystickDiv.addEventListener('touchend', () => {
        joystick.active = false;
        joystick.x = 0;
        joystick.y = 0;
      });

      skillButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameMode === 'single' && !surgeActive && surgeCooldown <= 0) {
          surgeActive = true;
          surgeTimer = 180;
        } else if (gameMode === 'multi' && socket && isAlive) {
          socket.emit('playerInput', { surge: true });
        }
      });

      lockButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        cameraLocked = !cameraLocked;
        lockButton.innerHTML = cameraLocked ? '<i class="fas fa-lock"></i> Unlock' : '<i class="fas fa-lock"></i> Lock';
      });
    }

    function updateJoystick() {
      let knob = document.getElementById('joystick-knob');
      knob.style.left = (50 + joystick.x) + 'px';
      knob.style.top = (50 + joystick.y) + 'px';
    }

    function updateLeaderboard() {
      leaderboard = [];
      if (gameMode === 'single' && player) {
        leaderboard.push({ name: player.name, size: floor(player.r) });
        for (let bot of bots) {
          leaderboard.push({ name: bot.name, size: floor(bot.r) });
        }
        leaderboard.sort((a, b) => b.size - a.size);
        leaderboard = leaderboard.slice(0, 10);
      }
    }

    function drawLeaderboard() {
      push();
      fill(0, 0, 50, 200);
      stroke(123, 104, 238);
      strokeWeight(2);
      rect(10, 10, 200, 260, 10);
      fill(123, 104, 238);
      textSize(14);
      textAlign(LEFT);
      textStyle(NORMAL);
      textFont('Press Start 2P');
      text('AURA Leaderboard', 20, 35);
      fill(255);
      textSize(12);
      if (gameMode === 'single') {
        for (let i = 0; i < leaderboard.length; i++) {
          text(`${i + 1}. ${leaderboard[i].name}: ${leaderboard[i].size}`, 20, 60 + i * 20);
        }
      } else if (Array.isArray(gameState.leaderboard)) {
        for (let i = 0; i < gameState.leaderboard.length; i++) {
          text(`${i + 1}. ${gameState.leaderboard[i].name}: ${gameState.leaderboard[i].size}`, 20, 60 + i * 20);
        }
      }
      pop();
    }

    function drawMinimap() {
      let miniWidth = 100;
      let miniHeight = 100;
      let scaleX = miniWidth / worldWidth;
      let scaleY = miniHeight / worldHeight;
      let isMobile = windowWidth < 768;

      push();
      if (isMobile) {
        translate(width - miniWidth - 10, 10);
      } else {
        translate(width - miniWidth - 10, height - miniHeight - 10);
      }

      fill(0, 0, 50, 200);
      stroke(123, 104, 238);
      strokeWeight(2);
      rect(0, 0, miniWidth, miniHeight, 5);

      fill(123, 104, 238);
      textSize(10);
      textFont('Press Start 2P');
      textAlign(LEFT);
      text('Cosmic Map', 5, 15);

      if (gameMode === 'single') {
        fill(75, 0, 130);
        noStroke();
        for (let zone of nebulaZones) {
          ellipse(zone.pos.x * scaleX, zone.pos.y * scaleY, zone.r * 2 * scaleX);
        }
        fill(255, 255, 0);
        for (let f of foods) {
          ellipse(f.pos.x * scaleX, f.pos.y * scaleY, f.r * 2 * scaleX);
        }
        fill(169, 169, 169);
        for (let vortex of vortexes) {
          ellipse(vortex.pos.x * scaleX, vortex.pos.y * scaleY, vortex.r * 2 * scaleX);
        }
        let [r, g, b] = hexToRgb(player.avatar.color);
        fill(r, g, b);
        ellipse(player.pos.x * scaleX, player.pos.y * scaleY, player.r * 2 * scaleX);
        for (let bot of bots) {
          let [br, bg, bb] = hexToRgb(bot.avatar.color);
          fill(br, bg, bb);
          ellipse(bot.pos.x * scaleX, bot.pos.y * scaleY, bot.r * 2 * scaleX);
        }
      } else {
        if (Array.isArray(gameState.nebulaZones)) {
          fill(75, 0, 130);
          noStroke();
          for (let zone of gameState.nebulaZones) {
            ellipse(zone.pos.x * scaleX, zone.pos.y * scaleY, zone.r * 2 * scaleX);
          }
        }
        if (Array.isArray(gameState.foods)) {
          fill(255, 255, 0);
          for (let f of gameState.foods) {
            ellipse(f.pos.x * scaleX, f.pos.y * scaleY, f.r * 2 * scaleX);
          }
        }
        if (Array.isArray(gameState.vortexes)) {
          fill(169, 169, 169);
          for (let vortex of gameState.vortexes) {
            ellipse(vortex.pos.x * scaleX, vortex.pos.y * scaleY, vortex.r * 2 * scaleX);
          }
        }
        if (gameState.players) {
          for (let id in gameState.players) {
            let p = gameState.players[id];
            let [r, g, b] = hexToRgb(p.avatar.color);
            fill(r, g, b);
            ellipse(p.pos.x * scaleX, p.pos.y * scaleY, p.r * 2 * scaleX);
          }
        }
        if (Array.isArray(gameState.bots)) {
          for (let bot of gameState.bots) {
            let [r, g, b] = hexToRgb(bot.avatar.color);
            fill(r, g, b);
            ellipse(bot.pos.x * scaleX, bot.pos.y * scaleY, bot.r * 2 * scaleX);
          }
        }
      }
      pop();
    }

    function drawSurgeStatus() {
      push();
      let isMobile = windowWidth < 768;
      let boxWidth = isMobile ? 50 : 110;
      let boxHeight = isMobile ? 110 : 50;
      let x = isMobile ? width - boxWidth - 10 : width - boxWidth - 10;
      let y = isMobile ? height / 2 - boxHeight / 2 : 10;

      fill(0, 0, 50, 200);
      stroke(123, 104, 238);
      strokeWeight(2);
      rect(x, y, boxWidth, boxHeight, 10);

      let maxDuration = 180;
      let maxCooldown = 300;
      let progress = 1;

      if (gameMode === 'single') {
        if (surgeActive) {
          progress = surgeTimer / maxDuration;
        } else if (surgeCooldown > 0) {
          progress = 1 - (surgeCooldown / maxCooldown);
        }
      } else if (gameState.players && gameState.players[playerId]) {
        let player = gameState.players[playerId];
        if (player.surgeActive) {
          progress = player.surgeTimer / maxDuration;
        } else if (player.surgeCooldown > 0) {
          progress = 1 - (player.surgeCooldown / maxCooldown);
        }
      }

      if (isMobile) {
        let barX = x + 15;
        let barY = y + 15;
        let barWidth = 20;
        let barHeight = 80;
        noStroke();
        fill(80);
        rect(barX, barY, barWidth, barHeight, 5);
        let filledHeight = barHeight * progress;
        if (progress < 1 && progress > 0) {
          fill(255, 87, 34);
        } else {
          fill(123, 104, 238);
        }
        rect(barX, barY + (barHeight - filledHeight), barWidth, filledHeight, 5);
        fill(123, 104, 238);
        textSize(10);
        textFont('Press Start 2P');
        textAlign(CENTER);
        text('SURGE', x + boxWidth / 2, y + 10);
      } else {
        let barX = x + 15;
        let barY = y + 30;
        let barWidth = 80;
        let barHeight = 10;
        noStroke();
        fill(80);
        rect(barX, barY, barWidth, barHeight, 5);
        if (progress < 1 && progress > 0) {
          fill(255, 87, 34);
        } else {
          fill(123, 104, 238);
        }
        rect(barX, barY, barWidth * progress, barHeight, 5);
        fill(123, 104, 238);
        textSize(10);
        textFont('Press Start 2P');
        textAlign(CENTER);
        text('SURGE', x + boxWidth / 2, y + 15);
      }
      pop();
    }

    function drawAbsorbStatus() {
      if (absorbTimer > 0) {
        push();
        let isMobile = windowWidth < 768;
        let boxWidth = isMobile ? 50 : 110;
        let boxHeight = isMobile ? 50 : 50;
        let x = isMobile ? width - boxWidth - 10 : width - boxWidth - 10;
        let y = isMobile ? height / 2 + 70 : 70;

        fill(0, 0, 50, 200);
        stroke(123, 104, 238);
        strokeWeight(2);
        rect(x, y, boxWidth, boxHeight, 10);

        let maxAbsorbTime = 600;
        let progress = absorbTimer / maxAbsorbTime;

        if (isMobile) {
          let barX = x + 15;
          let barY = y + 15;
          let barWidth = 20;
          let barHeight = 20;
          noStroke();
          fill(80);
          rect(barX, barY, barWidth, barHeight, 5);
          fill(255, 87, 34);
          rect(barX, barY, barWidth * progress, barHeight, 5);
          fill(123, 104, 238);
          textSize(10);
          textFont('Press Start 2P');
          textAlign(CENTER);
          text('ABSORB', x + boxWidth / 2, y + 10);
        } else {
          let barX = x + 15;
          let barY = y + 30;
          let barWidth = 80;
          let barHeight = 10;
          noStroke();
          fill(80);
          rect(barX, barY, barWidth, barHeight, 5);
          fill(255, 87, 34);
          rect(barX, barY, barWidth * progress, barHeight, 5);
          fill(123, 104, 238);
          textSize(10);
          textFont('Press Start 2P');
          textAlign(CENTER);
          text('ABSORB', x + boxWidth / 2, y + 15);
        }
        pop();
      }
    }

    class AuraOrb {
      constructor(x, y, r, isPlayer) {
        this.pos = createVector(x, y);
        this.r = r;
        this.vel = createVector(0, 0);
        this.isPlayer = isPlayer;
        this.target = isPlayer ? null : createVector(random(worldWidth), random(worldHeight));
        this.name = "";
        this.inNebulaZone = false;
        this.avatar = isPlayer ? avatar : { color: '#E6E6FA', accessory: 'âœ¨' };
        this.surgeActive = false;
        this.surgeTimer = 0;
        this.surgeCooldown = 0;
      }

      update() {
        let speedMultiplier = this.inNebulaZone ? 0.5 : 1;
        if (this.isPlayer && surgeActive) {
          speedMultiplier *= 3.8;
        }
        if (this.isPlayer) {
          let dir;
          if (isMobile && joystick.active) {
            dir = createVector(joystick.x * 5, joystick.y * 5);
          } else if (!cameraLocked) {
            let mouse = createVector(mouseX + cameraX, mouseY + cameraY);
            dir = p5.Vector.sub(mouse, this.pos);
          } else {
            dir = createVector(0, 0);
          }
          dir.setMag(3.6 * speedMultiplier / sqrt(this.r));
          this.vel.lerp(dir, 0.1);
        } else {
          let nearest = this.findNearestCollectible();
          if (nearest && p5.Vector.dist(this.pos, nearest.pos) < 200) {
            this.target = nearest.pos;
          } else if (p5.Vector.dist(this.pos, this.target) < 50) {
            this.target = createVector(random(worldWidth), random(worldHeight));
          }
          let dir = p5.Vector.sub(this.target, this.pos);
          dir.setMag(2 * speedMultiplier / sqrt(this.r));
          this.vel.lerp(dir, 0.05);
        }
        this.pos.add(this.vel);
        this.pos.x = constrain(this.pos.x, this.r, worldWidth - this.r);
        this.pos.y = constrain(this.pos.y, this.r, worldHeight - this.r);
      }

      findNearestCollectible() {
        let nearest = null;
        let minDist = Infinity;
        let collectibles = gameMode === 'single' ? [...stardust, ...foods] : [
          ...(Array.isArray(gameState.stardust) ? gameState.stardust : []),
          ...(Array.isArray(gameState.foods) ? gameState.foods : [])
        ];
        for (let c of collectibles) {
          let dist = p5.Vector.dist(this.pos, c.pos);
          if (dist < minDist) {
            minDist = dist;
            nearest = c;
          }
        }
        return nearest;
      }

      show() {
        let isHidden = false;
        let vortexArray = gameMode === 'single' ? vortexes : (Array.isArray(gameState.vortexes) ? gameState.vortexes : []);
        for (let vortex of vortexArray) {
          if (p5.Vector.dist(this.pos, vortex.pos) < vortex.r + this.r) {
            isHidden = true;
            break;
          }
        }
        push();
        let [r, g, b] = hexToRgb(this.avatar.color);
        fill(r, g, b, isHidden ? 100 : 255);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
        if (this.isPlayer) {
          for (let i = 0; i < 50; i++) {
            let angle = random(TWO_PI);
            let dist = random(this.r, this.r * 1.2);
            let x = this.pos.x + cos(angle) * dist;
            let y = this.pos.y + sin(angle) * dist;
            fill(r * 0.8, g * 0.8, b * 0.8, isHidden ? 50 : 200);
            ellipse(x, y, 3);
          }
        }
        fill(255, 255, 255, isHidden ? 100 : 255);
        textAlign(CENTER, CENTER);
        textSize(this.r * 1.2);
        textStyle(BOLD);
        text(this.avatar.accessory, this.pos.x, this.pos.y);
        fill(255, 255, 255, isHidden ? 100 : 255);
        textAlign(CENTER);
        textSize(12);
        text(this.name, this.pos.x, this.pos.y - this.r - 10);
        pop();
      }

      clears(collectible) {
        let d = p5.Vector.dist(this.pos, collectible.pos);
        if (d < this.r + collectible.r) {
          let area = PI * this.r * this.r + PI * collectible.r * collectible.r;
          this.r = sqrt(area / PI);
          return true;
        }
        return false;
      }

      clearsFood(food) {
        let d = p5.Vector.dist(this.pos, food.pos);
        if (d < this.r + food.r) {
          let area = PI * this.r * this.r + PI * 2 * 2;
          this.r = sqrt(area / PI);
          return true;
        }
        return false;
      }

      canClear(other) {
        let d = p5.Vector.dist(this.pos, other.pos);
        return this.r > other.r * 1.1 && d < this.r + other.r;
      }

      clearAuraOrb(other) {
        let area = PI * this.r * this.r + PI * other.r * other.r;
        this.r = sqrt(area / PI);
      }
    }

    class Stardust {
      constructor(x, y) {
        this.pos = createVector(x || random(worldWidth), y || random(worldHeight));
        this.r = 5;
      }

      show() {
        fill(75, 0, 130);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
      }
    }

    class Food {
      constructor(x, y) {
        this.pos = createVector(x || random(worldWidth), y || random(worldHeight));
        this.r = 3;
      }

      show() {
        fill(255, 255, 0);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
      }
    }

    class Vortex {
      constructor() {
        this.pos = createVector(random(worldWidth), random(worldHeight));
        this.r = 30;
      }

      show() {
        fill(169, 169, 169);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
      }
    }

    class NebulaZone {
      constructor() {
        this.pos = createVector(random(worldWidth), random(worldHeight));
        this.r = 100;
        this.spawnTimer = 0;
      }

      update() {
        this.spawnTimer++;
        if (this.spawnTimer >= 60) {
          let targetStardust = gameMode === 'single' ? stardust : (Array.isArray(gameState.stardust) ? gameState.stardust : []);
          let targetFoods = gameMode === 'single' ? foods : (Array.isArray(gameState.foods) ? gameState.foods : []);
          targetStardust.push(new Stardust(this.pos.x + random(-this.r, this.r), this.pos.y + random(-this.r, this.r)));
          targetFoods.push(new Food(this.pos.x + random(-this.r, this.r), this.pos.y + random(-this.r, this.r)));
          this.spawnTimer = 0;
        }
      }

      show() {
        push();
        fill(75, 0, 130, 150);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
        fill(123, 104, 238, 100);
        ellipse(this.pos.x, this.pos.y, this.r * 1.5);
        pop();
      }
    }

    function safeStorageAccess(key, value) {
      try {
        if (value !== undefined) {
          localStorage.setItem(key, value);
        } else {
          return localStorage.getItem(key);
        }
      } catch (e) {
        console.warn('Storage access failed:', e.message);
        return null;
      }
    }
  </script>
</body>
</html>